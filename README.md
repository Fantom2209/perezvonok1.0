## Установка

**Загрузить основные файлы в корень!**

Настроить файл конфигураций. Обязательно изменить следующие значения:

- `PATH_SEPARATOR` - разделитель для путей файловой системы (\ или /) 
- `PATH_ROOT` - путь до корневой папки проекта
- `URL_ROOT` - домен
- `DB_*` - заполнить поля для подключения к БД
- `APP_SECRET` - рандомная строка 

## Маршрутизация

`{controller}` - имя контроллера  
`{action}` - имя метода действия 

- Обычный маршрут: `http://site.local/{controller}/{action}/`
- Маршрут с параметрами 1: `http://site.local/controller/action/11/24/` - в контроллере параметры будут доступны по индексу (0 => 11, 1 => 24)
- Маршрут с параметрами 2: `http://site.local/controller/action/id:1/name:2/` - в контроллере параметры будут доступны по ассоциации ('id' => 11, 'name' => 24)
- Корневой маршрут: `http://site.local/` - использует контроллер `Home` и метод действия `Index`
- Маршрут без уточнения действия: `http://site.local/controller/` - использует метод действия `Index`

Обработка маршрута `http://site.local/user/create/` в зависимости от метода HTTP-запроса(GET/POST):

- GET - в контроллере `User` вызываем метод `Create()` 
- POST - в контроллере `User` вызываем метод `CreatePost()`. После POST-запроса представление не возвращаеться, необходимо произвести редирект.   

## Контроллеры 

**Директория:** `\app\lib\`
**Именование:** название файла идентично названию класса
**Базовый класс:** `\app\core\Page`

**Методы базового класса:**

**Система разграничения доступа к страницам:**

По умолчанию доступ к странице получают пользователи всех ролей. 

- `DeleteUserGroup($data = array())` - получаем массив ролей(id). Пользователи с удаленными ролями не имеют доступа к текущей странице.   
- `SetUserGroup($data = array())` - получаем массив ролей(id). Формурием список ролей для которых открыта текущая страница.   
- `HasAccess()` - Проверка прав активного пользователя на просмотр конкретной страницы `true/false`.   

Для управления доступом пользователей без роли используеться `id = 0`.

**Формирование данных для представления:**

- `Get($name)` - Получить значение по указанному имени.  
- `Set($name, $value)` - Добавить в список данные.

**Параметры с HTTP-запроса**

- `Param($index)` - получить данные с HTTP-запроса по индексу или ассоциации.

**Редирект:**

- `GenerateError($code = array())` - перейти на страницу ошибок. Передать необходимо массив с кодами ошибок.
- `NotFound()` - перейти на страницу ошибок c кодом 404.
- `Redirect($controller = 'Home', $action = 'Index', $param = array())` - сформировать ссылку и перейти по ней.
- `RedirectUrl($url = '/Home/Index/')` - перейти по конкретной ссылке.

## Представления 

**Директория:** `\app\view\`
**Шаблоны(Layout):** `\app\view\Shared\`
**Именование:** в папке view создаеться папка с именем Контроллера. Внутри папки-контроллера создаються папки с именами как у методов действия.

По умолчанию используеться шаблон `\app\view\Shared\mainLayout.php` и представление `\app\view\{controller}\{action}.php`. В контроллере можно переопределить оба значения по необходимости.

```php
	$this->view->Set('layout', Config::PATH_LAYOUT . 'errorLayout.php');
	$this->view->Set('template', Config::PATH_VIEW . 'otherLayout.php');
``` 

Получить данные в шаблоне и представлении можно так:

```php
	<h1><?php echo $this->Get('content');?></h1>
```

## Модель

**Директория:** `\app\data\`
**Именование:** название файла идентично названию таблице в базе данных. Если работа с базой не ведеться, название может быть любым.
**Базовый класс:** `\app\core\Model`

**Методы базового класса:**

**Основные**

- `Build()` - перед выполнением всех запросов (кроме прямых Query) необходимо провести построение запроса. Однажды построенный запрос можно выполнять большое количество раз.
- `Run($clear = false)` - выполнить запрос. Если переда параметр со значением true, то после выполнения запрос будет очищен. 
- `Clear()` - Сброс запроса.
- `Query($sql)` - указать конкретный запрос. Построение не требуеться.
- `SetOperData($data = array())` - задаем данные для запроса если таковые нужны.
- `GetLastId()` - получить последний добавленный\обновленный id.
- `IsSuccess()` - все ли хорошо? true\false.
- `ErrorReporting()` - вернуть массив с кодами возникших ошибок.
- `AddError($code)` - добавить ошибку в список.

**Запросы на выборку:**

- `Select($fields = array())` - указываем какие данные нам необходимы `array('field1','field1')`. Также предусмотрен подробный вариант, смотреть в премерах. Если нам нужны все столбцы ничего не передаем.
- `Binding($type, $table, $fieldMain, $fieldDop)` - осуществить привязку таблицы. `$type` - тип связи LEFT|RIGHT|.., `$table` - подключаемая таблица, `$fieldMain` - поле для привязки из основной выборки, `$fieldDop` - поле для привязки из дочерней таблицы.
- `Where($pattern, $fields = array())` - `$pattern` - шаблон предиката (смотреть в примерах), `$fields` - значения для подстановки (array(1,'value')).
- `OrderBy($fields, $code = 1)` - `$fields` - список полей, `$code` - тип сортировки (1 = ASC, 2 = DESC).
- `Limit($start = null, $count = null)` - Задать ограничения на количество выбираемых записей. `$start` - стартовая позиция, `$count` - количество.
- `GetAll()` - Получить все данные с последнего выполнения в виде ассоциативного массива.
- `GetNext()` - Получить одну запись с последнего выполнения в виде ассоциативного массива. Каждый вызов будет возвращать следидущую в списке запись. Когда записи закончатся вернется null. 
- `GetLast()` - Вернуть последнюю запись в виде ассоциативного массива. 
- `GetCount($val = null, $field = 'id')` - Количество записей. `$val` - значение для условия если нужно, `$field` - имя поля для условия и подсчета. 

**Запросы на добавление\обновление\удаление:**

- `Insert($data = array())` - добавить запись в БД. Подробнее смотреть в примере. 
- `Update($data = array()), $wherePattern = '', $whereData = array())` - обновить запись в БД. Подробнее смотреть в примере. 
- `Delete()` - удалить записи из БД. Можно прикрутить условие с помощью Where().

**Примеры формирования запросов**

```php
	$user = new \app\data\User();
	
	// Удалить запись с id = 3
	$user->Delete()->Where('`id` = ?', array(3))->Build()->Run();
	
	// Удалить все записи
	$user->Delete()->Build()->Run();
	
	
	//Добавить запись
	$user->Insert(
		array(
			'name' => 'Макс',
			'email' => 'maks@gmail.com',
			'site' => 'http://maks.com'
		)
	)->Run());
	
	// Запрос уже сформирован, теперь мы можем выполнять его с другими данными.
	
	$user->SetOperData(array('Антон','antom@mail.ru','http://anton.ru/'))->Run();
	
	//Обновить запись		
	$user->Update(
		array(
			'email' => 'maksimus@gmail.com',
			'site' => 'http://maksimus.com'
		), 'id = ?', array(3)				
	)->Run());
	
	//выбрать все записи со всеми столбцами
	$user->Select()->Build()->run();
	
	//указать нужные столбцы
	$user->Select('id', 'login')->Build()->run();
	
	//выборка из двух таблица
	$user->Select(array('login', 'roleName'))->Binding('LEFT','Role','idRole','id')->Build()->Run();
	
	//выборка из двух таблица(при конфликте полей в select передаем подробное описание)
	$user->Select(array(array('table' => 'p_User', 'field' => 'login'),array('table' => 'p_Role', 'field' => 'name')))->Binding('LEFT','Role','idRole','id')->Build()->Run();
	
	//выборка с условием
	$user->Select()->Where('`id` > ? `and` < ?', array(100, 30))->Build()->Run();
	
	//сортировка по убыванию
	$user->Select()->Where('`id` > ? `and` < ?', array(100, 30))->OrderBy(array('age'), 2)->Build()->Run();
	
	//выбрать первые 10 записей
	$user->Select()->Where('`id` > ? `and` < ?', array(100, 30))->OrderBy(array('age'), 2)->Limit(1,10)->Build()->Run();
	
	//получить результат запроса
	
	$d = $user->Select()->Build()->Run()->GetNext()); // первая строка

	$d = $user->GetNext(); // второй и т.д.
	$d = $user->Run()->GetAll(); // для сброса маркера выполнели последний сформированый запрос и выбрали все
	$d = $user->Run()->GetLast(); // для сброса маркера выполнели последний сформированый запрос и выбрали последнюю строку
```

Последовательность вызовов до построения запроса не имеет значения.

## Обработка форм

**Пример разметки формы**

```php
	<form action="<?php echo \app\helpers\Html::ActionPath('Account', 'Create')?>" method="POST" class="ajax-form">
		<div>
			<input type="text" name="UserData[Login:login]">
			<div class="error-box"></div>
		</div>
		<div>
			<input type="text" name="UserData[Email:email]">
			<div class="error-box"></div>
		</div>
		<div>
			<input type="password" name="UserData[Password:password]">
			<div class="error-box"></div>
		</div>
		<div>
			<input type="password" name="UserData[confirmPass]">
			<div class="error-box"></div>
		</div>
		<button>Регистрация</button>
	</form>
```

**Особенности разметки:**

- В `action` задаем путь. Проще всего это сделать через метод Html::ActionPath(...).
- Для работы с Ajax запросами достаточно форме дать класс `ajax-form`.
- Для отображения сообщений об ошибках после каждого поля задаем `<div class="error-box"></div>`.
- Для удобной валидации следует соблюдать следующие правила именования: Основные данные передаем массивом `UserData`. Имя поля состоит из двух частей - `Login:login`(Название правила валидации в Валидаторе:название поля в базе данных). Если поле не требует валидации то записываем его в упрощенном виде - `UserData[confirmPass]`.

Класс валидатор: `\app\helper\Validator.php`

**Реализованые правила валидации**

- `Email` - регулярка.
- `Phone` - регулярка.
- `DefaultText` - количество символов от 2 до 255.
- `Login` - DefaultText + только латинские символы и цифры.
- `UNumberShort` - число в диапазоне от 1 до 255.
- `Password` - латинские символы и цифры, количество символов от 7 до 16, как минимум одна буква.
- `Link` - регулярка.
		
При добавлении своих правил следует придерживаться следующего шаблона:

```php
	private function Check_{Название правила, его используем в форме}($data) {...}
```

**Пример валидации формы показаной выше**

```php
	$this->validator = new Validator();
	
	$data = $this->Param('UserData'); // получаем данные с формы
	$this->validator->Validate($data); // запускаем проверку
	
	if(!$this->validator->IsValid()){ // если есть поля, которые не соответствуют своему правилу 
		// обработка ошибки
		$this->response->SetError(ErrorInfo::GetMetaErrorItem(ErrorInfo::FIELD_EMAIL_NOT_FREE,array('email'))); // подробнее смотреть класс Ajax
	}
	else{
		$data = Validator::CleanKey($data); // очистка ключей данных (до 'DefaulText:name' => 'Вася' после 'name' => 'Вася')
		// работа с валидными данными
	}
	...
```

## Логирование

Файл логов: `\app\tmp\logs\log.txt`
Логер: `\apt\helpers\Loger.php`

**Писать в лог **

```php
	Loger::Write('Сообщение', 'Код ошибки, если есть');
```

## Формирование ответов (Ajax)

Класс: `\app\helpers\Ajax.php`

Все методы динамические:

- `SetFormat($format)` - задать тип контента в ответе (JSON (по умолчанию) - есть|XML - будет|..).
- `SetError($data)` - пометить ответ как: ошибка.
- `SetSuccess($data)` - пометить ответ как: успешно.
- `SetRedirect($url = '/home/index/')` - пометить ответ как: необходим редирект.
- `GetResponse()` - сформировать ответ.

Формат ответа:

```JSON
	{`code`:200, `status`:'success'}
	{`code`:500, `status`:'error', 'content':{'code':12, 'context':'login', 'Поле "login" не может быть пустым'}}
	{`code`:301, `status`:'redirect', 'url':'\error\index\23\'}
```

## Ошибки

Класс ошибок: `\app\core\ErrorInfo.php`

Статические методы:

- `GetMetaErrorItem($code, $data = array())` - возвращаем отчет об ошибке в виде `array('code' => $code, 'context' => 'contextName', 'msg' =>'msg')` - контекст всехда записываеться как $data[0].
- `GetMessage($code, $data = array())` - возвращаем сообщение об ошибке


```php
	self::UNDEFINED_ERROR => 'Произошла неопределенная ошибка!',
	self::FIELD_EMPTY => 'Поле "{0}" не может быть пустым!',
	self::FIELD_NOT_CORRECT => 'Поле "{0}" имеет некорректное значение!',
	self::FIELD_OUT_OF_RANGE_STR => 'Некорректное кол-во символов в поле "{0}"! Минимум: {1} - Максимум: {2}!',
	self::FIELD_OUT_OF_RANGE => 'Выход за границы диапазона в поле "{0}"! Минимум: {1} - Максимум: {2}!',
	self::FIELD_EASY_PASSWORD => 'Слишком простой пароль, используйте латинские буквы + цифры!',
	self::FIELD_CONFIRM_PASSWORD_NOT_CORRECT => 'Пароли не совпадают!',
	self::FIELD_LOGIN_NOT_FREE => 'Аккаунт с таким логином уже существует!',
	self::FIELD_EMAIL_NOT_FREE => 'Аккаунт с таким email`ом уже существует!',
	self::DB_CONNECT => 'Ошибка при подключении к базе данных!',
	self::DB_QUERY => 'Ошибка при выполнении запроса к базе данных!',
	self::DB_PREPARE_QUERY => 'Ошибка при формировании запроса к базе данных',
	self::USER_NOT_FOUND => 'Неверный логин или пароль'
```

## Ближайшая доработка

- `app\helpers\Email` - класс для отправки email.
- `app\helpers\Paginator` - класс для формирования постраничного деления.
- `Подтверждение email` 


